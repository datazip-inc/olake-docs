---
title: "Setting Up OLake Development Environment | Contributor Guide"
description: Setting up a Development Environment in OLake guide
sidebar_label: Setting up a Development Environment
sidebar_position: 3
---

# A Complete Detailed Walkthrough of How to Setup, Sync and Debug with Live Demo

:::important Read before you start
If you're new to Data Engineering, Docker, or Golang, start with the [**Learning Modules**](/docs/community/learning-modules) page to learn the fundamentals before proceeding.
:::

# Setting up a Development Environment

Watch this comprehensive video tutorial that walks you through the entire process of setting up OLake, syncing data, and debugging with a live demonstration:

<span id="setup-video-tutorial"></span>

<YouTubeEmbed videoId="IcAJmW72d2A" className="max-w-6xl" /><br/>

**Pre-requisites:**

Before setting up and running OLake, ensure you have all the following installed on your system:

<Tabs>
<TabItem value="java" label="Java" default>
**The version of Java required is 21.**

<Tabs>
<TabItem value="mac_java" label="macOS" default>
```bash
brew install openjdk@21
```
</TabItem>

<TabItem value="linux_java" label="Linux (Ubuntu)">
```bash
sudo apt update
sudo apt install openjdk-21-jdk
```
</TabItem>

<TabItem value="windows_java" label="Windows">

**Option A: Using `winget` (Recommended)**
```powershell
winget install Oracle.JDK.21
```

**Option B: Manual Download**

Please follow the link to install Java 21 on Windows: [JDK 21](https://www.oracle.com/in/java/technologies/downloads/#jdk21-windows)

**Verify Installation:**
```powershell
java -version
```

:::caution JAVA_HOME Environment Variable
If `mvn` or other Java-based tools fail later with _"JAVA_HOME is not set"_, you need to set it manually:
```powershell
# Find your Java installation path
Get-Command java | Select-Object -ExpandProperty Source

# Set JAVA_HOME for the current session
$env:JAVA_HOME = "C:\Program Files\Java\jdk-21"

# To set it permanently, use System Properties > Environment Variables
# or run (requires admin PowerShell):
[System.Environment]::SetEnvironmentVariable("JAVA_HOME", "C:\Program Files\Java\jdk-21", "Machine")
```
:::

</TabItem>
</Tabs>
</TabItem>

<TabItem value="golang" label="Golang">
**The version of Golang required is 1.25.**

<Tabs>
<TabItem value="mac_go" label="macOS" default>
```bash
brew install go@1.25
```
</TabItem>

<TabItem value="linux_go" label="Linux (Ubuntu)">
```bash
sudo snap install go --classic
# or download from https://go.dev/dl/ and follow installation instructions
```
</TabItem>

<TabItem value="windows_go" label="Windows">

**Option A: Using `winget` (Recommended)**
```powershell
winget install GoLang.Go
```

**Option B: Manual Download**

Please follow the link to install Golang 1.25 on Windows: [Go 1.25](https://go.dev/dl/)

**Verify Installation:**
```powershell
go version
```

:::tip
After installing Go via `winget`, you may need to **restart your terminal** (or open a new PowerShell window) for the `go` command to be available in your PATH.
:::

</TabItem>
</Tabs>
</TabItem>

<TabItem value="nodejs" label="Node.js">
**The version of NodeJS required is 22.19.0.**

<Tabs>
<TabItem value="mac_nodejs" label="macOS" default>
```bash
brew install node@22
```
</TabItem>

<TabItem value="linux_nodejs" label="Linux (Ubuntu)">
```bash
curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
sudo apt-get install -y nodejs
```
</TabItem>

<TabItem value="windows_nodejs" label="Windows">

**Option A: Using `winget` (Recommended)**
```powershell
winget install OpenJS.NodeJS.LTS
```

**Option B: Manual Download**

Please follow the link to install Node.js 22.19.0 on Windows: [Node.js 22.19.0](https://nodejs.org/en/download)

**Verify Installation:**
```powershell
node -v
```

</TabItem>
</Tabs>
</TabItem>

<TabItem value="docker" label="Docker">
<Tabs>
<TabItem value="mac_docker" label="macOS" default>
```bash
brew install --cask docker
```
</TabItem>

<TabItem value="linux_docker" label="Linux (Ubuntu)">
```bash
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update

# Install Docker packages:
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```
</TabItem>

<TabItem value="windows_docker" label="Windows">

**Option A: Using `winget`**
```powershell
winget install Docker.DockerDesktop
```

**Option B: Manual Download**

Please follow the link to install Docker on Windows: [Docker Desktop](https://docs.docker.com/desktop/setup/install/windows-install/)

:::important WSL2 Required
Docker Desktop for Windows requires **WSL2** (Windows Subsystem for Linux 2) as its backend. If not already installed, run the following in an **Administrator** PowerShell:
```powershell
wsl --install
```
Restart your computer after installation. After restarting, launch Docker Desktop and ensure it starts without errors before proceeding.
:::

**Verify Installation:**
```powershell
docker --version
docker compose version
```

</TabItem>
</Tabs>
</TabItem>

<TabItem value="maven" label="Maven">
<Tabs>
<TabItem value="mac_maven" label="macOS" default>
```bash
brew install maven
```
</TabItem>

<TabItem value="linux_maven" label="Linux (Ubuntu)">
```bash
sudo apt install maven -y
```
</TabItem>

<TabItem value="windows_maven" label="Windows">

**Option A: Using `winget` (Recommended)**
```powershell
winget install Apache.Maven
```

**Option B: Manual Download**

Please follow the link to install Maven on Windows: [Maven](https://maven.apache.org/download.cgi)

**Verify Installation:**
```powershell
mvn -v
```

</TabItem>
</Tabs>
</TabItem>
</Tabs>

:::danger[Attention!!]

To better understand the workflow, let's walk through an example using **Postgres** as the source and the destination as **Iceberg**.

:::

## 1. Source and Destination Setup

Use the following command to quickly spin up the source (Postgres/MongoDB/MySQL) and destination (Iceberg/Parquet Writer) services using Docker Compose. This will download the required docker-compose files and start the containers in the background.

<Tabs>
<TabItem value="bash" label="macOS / Linux" default>
```bash
sh -c 'curl -fsSL https://raw.githubusercontent.com/datazip-inc/olake-docs/master/docs/community/docker-compose.yml -o docker-compose.source.yml && \
curl -fsSL https://raw.githubusercontent.com/datazip-inc/olake/master/destination/iceberg/local-test/docker-compose.yml -o docker-compose.destination.yml && \
docker compose -f docker-compose.source.yml --profile postgres -f docker-compose.destination.yml up -d'
```
</TabItem>
<TabItem value="powershell" label="Windows (PowerShell)">
```powershell
# Step 1: Download source docker-compose
Invoke-WebRequest -Uri "https://raw.githubusercontent.com/datazip-inc/olake-docs/master/docs/community/docker-compose.yml" -OutFile "docker-compose.source.yml"

# Step 2: Download destination docker-compose (Iceberg)
Invoke-WebRequest -Uri "https://raw.githubusercontent.com/datazip-inc/olake/master/destination/iceberg/local-test/docker-compose.yml" -OutFile "docker-compose.destination.yml"

# Step 3: Start all source and destination containers
docker compose -f docker-compose.source.yml --profile postgres -f docker-compose.destination.yml up -d
```

:::tip Verify containers are running
After starting, verify all containers are healthy:
```powershell
docker compose -f docker-compose.source.yml --profile postgres -f docker-compose.destination.yml ps
```
:::
</TabItem>
</Tabs>

:::note

- To use MongoDB, replace `--profile postgres` with `--profile mongo`.
- To use MySQL, replace `--profile postgres` with `--profile mysql`.

:::

## 2. OLake CLI Setup

The diagram below illustrates the high-level architecture of OLake, showing how data flows from various sources to different destinations:

![OLake data flow from MongoDB, Postgres, MySQL sources to Iceberg and Parquet destinations](/img/community/setting-up-a-dev-env/olake_diagram.webp)

<details>
<summary>How this local OLake architecture works</summary>

The diagram represents a **complete local OLake pipeline** that you can run on your laptop using Docker Compose and the OLake CLI.

On the **left side**, you have your **operational databases**. In this setup, we provide three options:
- **Postgres**
- **MySQL**
- **MongoDB**

You choose which one to run by switching the Docker Compose `--profile` flag.  
Each source container exposes a database with a **dummy table pre-populated with sample data** (for example, simple customer/order-style records), so that you can immediately run initial loads and incremental or change-data-capture (CDC) syncs without having to insert data manually.

In the **middle of the diagram** is **OLake**, which acts as the **replication and transformation engine**:
- It connects to the selected source using the settings you define in `source.json` (host, port, credentials, CDC configuration, etc.).
- It reads **new rows and changes** (inserts/updates/deletes) from the source in case of cdc or incremental syncs.
- It applies transformations on the data such as **normalization** and **partitioning** if applied by the user.
- It then routes that data to the configured destination using `destination.json`, handling schema mapping and partitioning as needed.

On the **right side of the diagram** are the **analytics destinations**, where OLake writes the data:

- **Iceberg destination**  
  - OLake writes rows into **Apache Iceberg tables**.  
  - In local mode, the Iceberg catalog is backed by **MinIO** (an S3-compatible object storage running locally), and in real deployments it can use **Amazon S3** or any S3-compatible storage.  
  - OLake handles creating and updating Iceberg table files and metadata, so you can query these tables via the **Spark + Iceberg** service that is part of this local setup.

- **Parquet destination**  
  - OLake writes data as **plain Parquet files** directly into a bucket. In local mode, the bucket is in **MinIO** (an S3-compatible object storage running locally), and in real deployments it can use **Amazon S3** or any S3-compatible storage.
  - This is useful when you want a simple folder of Parquet files for lightweight analytics or debugging, without the additional table-layer that Iceberg provides.

Putting it together, the image shows that **OLake sits between your transactional databases (Postgres/MySQL/MongoDB) and your analytical storage (Iceberg tables or Parquet files on MinIO/S3)**.  
You can swap sources and destinations just by changing the Docker profile and your `source.json`/`destination.json`, while OLake consistently takes care of **moving and organizing the data from source to lakehouse**.
</details>

### Fork and Clone

Clone the OLake repository and navigate to the project directory:

<Tabs>
<TabItem value="ssh" label="SSH (macOS / Linux)" default>
```bash
git clone git@github.com:datazip-inc/olake.git && cd olake
```
</TabItem>
<TabItem value="https" label="HTTPS (Recommended for Windows)">
```powershell
git clone https://github.com/datazip-inc/olake.git
Set-Location olake
```
</TabItem>
</Tabs>

:::note
- For contributing, you can [fork the repository on GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/about-forks) first, then clone your fork.
- All OLake CLI commands mentioned below must be run from this **root directory**.
- You'll create `source.json` and `destination.json` configuration files in the steps below, store them in the **root directory** for simplicity.
:::

### Set up Source (source.json)

<Tabs>
<TabItem value="postgres cli" label="Postgres" default>
**This setup is using the above provided docker compose for Postgres.**
```json title="source.json"
{
  "host": "localhost",
  "port": 5431,
  "database": "main",
  "username": "main",
  "password": "password",
  "jdbc_url_params": {},
  "ssl": {
    "mode": "disable"
  },
  "update_method": {
    "replication_slot": "postgres_slot",
    "publication": "olake_publication",
    "initial_wait_time": 120
  },
  "reader_batch_size": 1000,
  "max_threads": 10
}
```
</TabItem>

<TabItem value="mongodb cli" label="MongoDB" default>

**This setup is using the above provided docker compose for MongoDB.**

```json title="source.json"
{
  "hosts": ["localhost:27017"],
  "username": "admin",
  "password": "password",
  "authdb": "admin",
  "replica_set": "rs0",
  "read_preference": "secondaryPreferred",
  "srv": false,
  "database": "reddit",
  "max_threads": 5,
  "backoff_retry_count": 4,
  "chunking_strategy": "splitVector"
}
```

</TabItem>
<TabItem value="mysql cli" label="MySQL" default>

**This setup is using the above provided docker compose for MySQL.**

```json title="source.json"
{
  "hosts": "localhost",
  "username": "root",
  "password": "password",
  "database": "main",
  "port": 3306,
  "update_method": {
    "initial_wait_time": 10
  },
  "tls_skip_verify": true,
  "max_threads": 5,
  "backoff_retry_count": 4
}
```

</TabItem>
<TabItem value="oracle cli" label="Oracle" default>
You can use your own Oracle configuration. The docker compose is **WIP**.
</TabItem>
<TabItem value="kafka cli" label="Kafka" default>
You can use your own Kafka configuration. The docker compose is **WIP**.
</TabItem>
</Tabs>

### Set up Destination (destination.json)

<Tabs>
<TabItem value="iceberg cli" label="Iceberg" default>
**This setup is using the above provided docker compose for Iceberg.**
```json title="destination.json"
{
  "type": "ICEBERG",
  "writer": {
    "catalog_type": "jdbc",
    "jdbc_url": "jdbc:postgresql://localhost:5432/iceberg",
    "jdbc_username": "iceberg",
    "jdbc_password": "password",
    "iceberg_s3_path": "s3a://warehouse",
    "s3_endpoint": "http://localhost:9000",
    "s3_use_ssl": false,
    "s3_path_style": true,
    "aws_access_key": "admin",
    "aws_secret_key": "password",
    "iceberg_db": "olake_iceberg",
    "aws_region": "us-east-1"
  }
}
```
</TabItem>
<TabItem value="parquet cli" label="S3 Parquet" default>
**This setup is using the above provided docker compose for S3 Parquet.**
```json title="destination.json"
{
  "type": "PARQUET",
  "writer": {
    "s3_bucket": "warehouse",
    "s3_region": "us-east-1",
    "s3_access_key": "admin",
    "s3_secret_key": "password",
    "s3_endpoint": "http://localhost:9000",
    "s3_path": ""
  }
}
```
</TabItem>
</Tabs>

## 3. Commands to run OLake code

:::important
You **must** review the **Discover** and **Sync** commands in the [Commands and Flags](/docs/community/commands-and-flags) page before proceeding. These sections contain essential information about all available flags and options:
- [Discover Command](/docs/community/commands-and-flags#3-discover)
- [Sync Command](/docs/community/commands-and-flags#4-sync)
:::

### Discover Command

Initially, you have to run the discover command which generates a `streams.json` file which contains all the possible streams. It requires the source name and source config path, with command type `discover`.

<Tabs>
<TabItem value="bash" label="macOS / Linux" default>
```bash
./build.sh driver-postgres discover --config $(pwd)/source.json
```
</TabItem>
<TabItem value="powershell" label="Windows (PowerShell)">
```powershell
# On Windows, use 'go run' directly instead of build.sh
go run ./drivers/postgres/main.go discover --config "$PWD\source.json"
```
</TabItem>
</Tabs>

:::note Windows Users
The `go run` command compiles and runs the Go code directly. Unlike `./build.sh`, it does **not** automatically build the Iceberg Java JAR. If you're using Iceberg as your destination, you must [build the JAR manually](#6-debugging) before running sync commands.
:::

The following video provides a comprehensive guide on the `streams.json` file structure and how to configure it for your use case:

<YouTubeEmbed videoId="ZCrufTLtgSw" className="max-w-6xl" /><br/>

If you want to learn more about `streams.json` file and how to modify it. Refer to the [Docker CLI guide](/docs/install/docker-cli#streams-config).

### Sync Command

The sync command is used to sync data from the source to the destination. OLake supports three different sync modes:

<Tabs>
<TabItem value="full-refresh" label="Full Refresh" default>

**Full Refresh** syncs the entire dataset from the source to the destination. It performs a complete copy of all data present in the source to the destination, essentially replacing the destination data with a fresh copy from the source.

For the first full refresh, run the sync command without the `--state` flag:

<Tabs>
<TabItem value="bash_fr" label="macOS / Linux" default>
```bash
./build.sh driver-postgres sync --config $(pwd)/source.json --catalog $(pwd)/streams.json --destination $(pwd)/destination.json
```
</TabItem>
<TabItem value="ps_fr" label="Windows (PowerShell)">
```powershell
# Run full refresh sync (compiles and executes in one step)
go run ./drivers/postgres/main.go sync --config "$PWD\source.json" --catalog "$PWD\streams.json" --destination "$PWD\destination.json"
```
</TabItem>
</Tabs>

After this initial sync completes, a `state.json` and `stats.json` file are automatically generated. The `state.json` file contains the necessary resume tokens and metadata that OLake uses for CDC (Change Data Capture) or Incremental sync operations. Essentially, it tells OLake from where to resume or start the next sync.

</TabItem>

<TabItem value="incremental" label="Incremental Sync">

**Incremental Sync** is an **append-only operation** that syncs only new records based on cursor fields. You configure a primary cursor field (and optionally a secondary cursor field) in your `streams.json`. On the first run, a full refresh occurs automatically. After that, OLake only syncs records where the cursor field value is greater than the maximum value stored from the previous sync. 

:::note
Modifications or deletions to existing records in the source will **not** be reflected in the destination.
:::

Run the sync command with the `--state` flag enabled:

<Tabs>
<TabItem value="bash_inc" label="macOS / Linux" default>
```bash
./build.sh driver-postgres sync --config $(pwd)/source.json --catalog $(pwd)/streams.json --destination $(pwd)/destination.json --state $(pwd)/state.json
```
</TabItem>
<TabItem value="ps_inc" label="Windows (PowerShell)">
```powershell
# Run incremental sync with state tracking
go run ./drivers/postgres/main.go sync --config "$PWD\source.json" --catalog "$PWD\streams.json" --destination "$PWD\destination.json" --state "$PWD\state.json"
```
</TabItem>
</Tabs>

To learn how Incremental sync works in OLake, including how it tracks changes and resumes from previous sync points, watch the following video:

<YouTubeEmbed videoId="VXfB5CftTG0" className="max-w-6xl" /><br/>

</TabItem>

<TabItem value="cdc" label="CDC (Change Data Capture)">

**CDC (Change Data Capture)** is an upsert mode operation that tracks and replicates all changes made in the source database to the destination. It checks for any inserts, updates, or deletes in the source and performs similar changes in the destination, ensuring the destination stays in sync with the source.

This ensures that OLake continues from where it left off, only syncing new or changed data since the last sync operation.

Run the sync command with the `--state` flag enabled:

<Tabs>
<TabItem value="bash_cdc" label="macOS / Linux" default>
```bash
./build.sh driver-postgres sync --config $(pwd)/source.json --catalog $(pwd)/streams.json --destination $(pwd)/destination.json --state $(pwd)/state.json
```
</TabItem>
<TabItem value="ps_cdc" label="Windows (PowerShell)">
```powershell
# Run CDC sync with state tracking (captures inserts, updates, and deletes)
go run ./drivers/postgres/main.go sync --config "$PWD\source.json" --catalog "$PWD\streams.json" --destination "$PWD\destination.json" --state "$PWD\state.json"
```
</TabItem>
</Tabs>

To learn how CDC sync works in OLake, including how it tracks changes and resumes from previous sync points, watch the [comprehensive video tutorial](#setup-video-tutorial) above.


</TabItem>
</Tabs>

## 4. Query Data after the Sync

    After running the sync command, you can query your data using the Spark Iceberg service available at [`localhost:8888`](http://localhost:8888).

    :::tip Windows Users
    If port `8888` is already in use (e.g., by Jupyter or Anaconda), check with:
    ```powershell
    netstat -ano | findstr :8888
    ```
    You can stop the conflicting process or change the port mapping in `docker-compose.destination.yml`.
    :::

    For example, run the following SQL commands to explore your synced data:

    ```sql
    %%sql
    SELECT * FROM olake_iceberg.postgres_main_public.sample_data;
    ``` 

## 5. Demo workflow

You can follow these steps to try out CDC or Incremental sync functionality:

:::info
- **For Incremental Sync**: Only run the **Insert Records** operation (Step 1) below, as incremental sync only handles new records and does not track updates or deletes.
- **For CDC**: You can try out all operations below (Insert, Update, and Delete) as CDC tracks all changes including inserts, updates, and deletes.
- If you want to know more about OLake generated variables like `op_type`, check out the [OLake Generated Columns](/docs/understanding/terminologies/olake#olake-generated-columns) section.
:::

When running sync with state mode enabled, you can verify Change Data Capture/Incremental functionality by following these example steps:

1. **Insert Records**: Insert 2 records in the source database and confirm that both records are replicated in the destination table. Run the following command:

   ```bash
   docker exec -it primary_postgres psql -U main -d main -c "INSERT INTO public.sample_data (id, num_col, str_col) VALUES (10, 100, 'First record'), (20, 200, 'Second record');"
   ```

   Now run sync with state enabled:

   <Tabs>
   <TabItem value="bash_demo1" label="macOS / Linux" default>
   ```bash
   ./build.sh driver-postgres sync --config $(pwd)/source.json --catalog $(pwd)/streams.json --destination $(pwd)/destination.json --state $(pwd)/state.json
   ```
   </TabItem>
   <TabItem value="ps_demo1" label="Windows (PowerShell)">
   ```powershell
   go run ./drivers/postgres/main.go sync --config "$PWD\source.json" --catalog "$PWD\streams.json" --destination "$PWD\destination.json" --state "$PWD\state.json"
   ```
   </TabItem>
   </Tabs>

   After the sync is completed, execute the SQL query from the previous section on `localhost:8888`. You should see 2 additional rows with `op_type` indicating `"c"` for created.

2. **Update Record**: Update 1 record in the source database and observe the corresponding update in the destination table. Run the following command:

   ```sql title="sql"
   docker exec -it primary_postgres psql -U main -d main -c "UPDATE public.sample_data SET num_col = 150, str_col = 'First record updated' WHERE id = 1;"
   ```

   Now run sync with state enabled:

   <Tabs>
   <TabItem value="bash_demo2" label="macOS / Linux" default>
   ```bash
   ./build.sh driver-postgres sync --config $(pwd)/source.json --catalog $(pwd)/streams.json --destination $(pwd)/destination.json --state $(pwd)/state.json
   ```
   </TabItem>
   <TabItem value="ps_demo2" label="Windows (PowerShell)">
   ```powershell
   go run ./drivers/postgres/main.go sync --config "$PWD\source.json" --catalog "$PWD\streams.json" --destination "$PWD\destination.json" --state "$PWD\state.json"
   ```
   </TabItem>
   </Tabs>

   After the sync is completed, execute the SQL query from the previous section on `localhost:8888`. You can notice that the `op_type` for this record will indicate `"u"` for updated.

3. **Delete Records**: Delete 2 records in the source database and confirm the records reflect the deletion in the destination. Run the following command:

   ```sql title="sql"
   docker exec -it primary_postgres psql -U main -d main -c "DELETE FROM public.sample_data WHERE id IN (1, 10);"
   ```

   Now run sync with state enabled:

   <Tabs>
   <TabItem value="bash_demo3" label="macOS / Linux" default>
   ```bash
   ./build.sh driver-postgres sync --config $(pwd)/source.json --catalog $(pwd)/streams.json --destination $(pwd)/destination.json --state $(pwd)/state.json
   ```
   </TabItem>
   <TabItem value="ps_demo3" label="Windows (PowerShell)">
   ```powershell
   go run ./drivers/postgres/main.go sync --config "$PWD\source.json" --catalog "$PWD\streams.json" --destination "$PWD\destination.json" --state "$PWD\state.json"
   ```
   </TabItem>
   </Tabs>

   After the sync is completed, execute the SQL query from the previous section on `localhost:8888`. You can notice that the `op_type` for these records will indicate `"d"` for deleted (with other fields as NONE).

## 6. Debugging

While running the build command, you can add print statements to debug the flow. If you prefer using a debugger with **VSCode**, please follow the section below.

If you don't want to run the sync commands after every change, you can use this debugger mode for the Go side of the code.
:::caution Iceberg JAR Required
If using Iceberg as destination, you need to generate the jar file for the Java side of code and move it to the correct location. **This step is mandatory for Windows users** since `go run` (used in place of `build.sh`) does not auto-generate the JAR.

1. **Generate the jar file** by running the Maven command in the Java writer directory:
   <Tabs>
   <TabItem value="bash_jar" label="macOS / Linux" default>
   ```bash
   cd /[PATH_TO_OLAKE_CODE]/olake/destination/iceberg/olake-iceberg-java-writer
   mvn clean package -DskipTests
   ```
   </TabItem>
   <TabItem value="ps_jar" label="Windows (PowerShell)">
   ```powershell
   # Navigate to the Java writer directory (adjust path to your setup)
   Set-Location "$PWD\destination\iceberg\olake-iceberg-java-writer"

   # Build the JAR (requires Java 21 and Maven)
   mvn clean package -DskipTests
   ```
   </TabItem>
   </Tabs>

2. **Move the generated jar file** from the target directory to the iceberg destination directory:
   <Tabs>
   <TabItem value="bash_cp" label="macOS / Linux" default>
   ```bash
   cp /[PATH_TO_OLAKE_CODE]/olake/destination/iceberg/olake-iceberg-java-writer/target/olake-iceberg-java-writer-0.0.1-SNAPSHOT.jar /[PATH_TO_OLAKE_CODE]/olake/destination/iceberg/
   ```
   </TabItem>
   <TabItem value="ps_cp" label="Windows (PowerShell)">
   ```powershell
   # Copy the built JAR to the iceberg destination directory
   Copy-Item "target\olake-iceberg-java-writer-0.0.1-SNAPSHOT.jar" "..\olake-iceberg-java-writer-0.0.1-SNAPSHOT.jar"

   # Return to the olake root directory
   Set-Location ..\..\..
   ```
   </TabItem>
   </Tabs>

Alternatively, on macOS/Linux you can generate the jar file by running the `./build.sh sync` command once, which will automatically handle the jar generation process.
:::

### Steps to Debug
- Create a `.vscode` directory inside the OLake project root if it doesn't already exist.
- Create a file named `launch.json` inside the `.vscode` directory and paste the below config.

<details>
  <summary>Click to view `.vscode/launch.json`</summary>
```json title=".vscode/launch.json"
{
  "version": "0.2.0",
  "configurations": [
      {
          "name": "MySQL: Check",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mysql/main.go",
          "mode": "auto",
          "args": [
              "check",
              "--config",
              "${workspaceFolder}/drivers/mysql/examples/config.json"
          ]
      },
      {
          "name": "MySQL: Discover",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mysql/main.go",
          "mode": "auto",
          "args": [
              "discover",
              "--config",
              "${workspaceFolder}/drivers/mysql/examples/config.json"
          ]
      },
      {
          "name": "MySQL: Sync (No State)",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mysql/main.go",
          "mode": "auto",
          "args": [
              "sync",
              "--config",
              "${workspaceFolder}/drivers/mysql/examples/config.json",
              "--catalog",
              "${workspaceFolder}/drivers/mysql/examples/streams.json",
              "--destination",
              "${workspaceFolder}/drivers/mysql/examples/write.json"
          ]
      },
      {
          "name": "MySQL: Sync (With State)",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mysql/main.go",
          "mode": "auto",
          "args": [
              "sync",
              "--config",
              "${workspaceFolder}/drivers/mysql/examples/config.json",
              "--catalog",
              "${workspaceFolder}/drivers/mysql/examples/streams.json",
              "--destination",
              "${workspaceFolder}/drivers/mysql/examples/write.json",
              "--state",
              "${workspaceFolder}/drivers/mysql/examples/state.json"
          ]
      },
      {
          "name": "MongoDB: Check",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mongodb/main.go",
          "mode": "auto",
          "args": [
              "check",
              "--config",
              "${workspaceFolder}/drivers/mongodb/examples/config.json"
          ]
      },
      {
          "name": "MongoDB: Discover",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mongodb/main.go",
          "mode": "auto",
          "args": [
              "discover",
              "--config",
              "${workspaceFolder}/drivers/mongodb/examples/config.json"
          ]
      },
      {
          "name": "MongoDB: Sync (No State)",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mongodb/main.go",
          "mode": "auto",
          "args": [
              "sync",
              "--config",
              "${workspaceFolder}/drivers/mongodb/examples/config.json",
              "--catalog",
              "${workspaceFolder}/drivers/mongodb/examples/streams.json",
              "--destination",
              "${workspaceFolder}/drivers/mongodb/examples/write.json"
          ]
      },
      {
          "name": "MongoDB: Sync (With State)",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mongodb/main.go",
          "mode": "auto",
          "args": [
              "sync",
              "--config",
              "${workspaceFolder}/drivers/mongodb/examples/config.json",
              "--catalog",
              "${workspaceFolder}/drivers/mongodb/examples/streams.json",
              "--destination",
              "${workspaceFolder}/drivers/mongodb/examples/write.json",
              "--state",
              "${workspaceFolder}/drivers/mongodb/examples/state.json"
          ]
      },
      {
          "name": "PostgreSQL: Check",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/postgres/main.go",
          "mode": "auto",
          "args": [
              "check",
              "--config",
              "${workspaceFolder}/drivers/postgres/examples/config.json"
          ]
      },
      {
          "name": "PostgreSQL: Discover",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/postgres/main.go",
          "mode": "auto",
          "args": [
              "discover",
              "--config",
              "${workspaceFolder}/drivers/postgres/examples/config.json"
          ]
      },
      {
          "name": "PostgreSQL: Sync (No State)",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/postgres/main.go",
          "mode": "auto",
          "args": [
              "sync",
              "--config",
              "${workspaceFolder}/drivers/postgres/examples/config.json",
              "--catalog",
              "${workspaceFolder}/drivers/postgres/examples/streams.json",
              "--destination",
              "${workspaceFolder}/drivers/postgres/examples/write.json"
          ]
      },
      {
          "name": "PostgreSQL: Sync (With State)",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/postgres/main.go",
          "mode": "auto",
          "args": [
              "sync",
              "--config",
              "${workspaceFolder}/drivers/postgres/examples/config.json",
              "--catalog",
              "${workspaceFolder}/drivers/postgres/examples/streams.json",
              "--destination",
              "${workspaceFolder}/drivers/postgres/examples/write.json",
              "--state",
              "${workspaceFolder}/drivers/postgres/examples/state.json"
          ]
      },
      {
          "name": "Oracle: Check",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/oracle/main.go",
          "mode": "auto",
          "args": [
              "check",
              "--config",
              "${workspaceFolder}/drivers/oracle/examples/config.json"
          ]
      },
      {
          "name": "Oracle: Discover",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/oracle/main.go",
          "mode": "auto",
          "args": [
              "discover",
              "--config",
              "${workspaceFolder}/drivers/oracle/examples/config.json"
          ]
      },
      {
          "name": "Oracle: Sync (No State)",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/oracle/main.go",
          "mode": "auto",
          "args": [
              "sync",
              "--config",
              "${workspaceFolder}/drivers/oracle/examples/config.json",
              "--catalog",
              "${workspaceFolder}/drivers/oracle/examples/streams.json",
              "--destination",
              "${workspaceFolder}/drivers/oracle/examples/write.json"
          ]
      },
      {
          "name": "Oracle: Sync (With State)",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/oracle/main.go",
          "mode": "auto",
          "args": [
              "sync",
              "--config",
              "${workspaceFolder}/drivers/oracle/examples/config.json",
              "--catalog",
              "${workspaceFolder}/drivers/oracle/examples/streams.json",
              "--destination",
              "${workspaceFolder}/drivers/oracle/examples/write.json",
              "--state",
              "${workspaceFolder}/drivers/oracle/examples/state.json"
          ]
      },
      {
          "name": "MySQL: Spec",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mysql/main.go",
          "mode": "auto",
          "args": [
              "spec"
          ]
      },
      {
          "name": "MongoDB: Spec",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/mongodb/main.go",
          "mode": "auto",
          "args": [
              "spec"
          ]
      },
      {
          "name": "PostgreSQL: Spec",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/postgres/main.go",
          "mode": "auto",
          "args": [
              "spec"
          ]
      },
      {
          "name": "Oracle: Spec",
          "type": "go",
          "request": "launch",
          "program": "${workspaceFolder}/drivers/oracle/main.go",
          "mode": "auto",
          "args": [
              "spec"
          ]
      }
  ]
}
```
</details>

### Params:
| key | value(s) |
| --- | --- |
|`mode` | `auto`, `debug` |
| `args` | `sync` , `discover`, `check` |

Update `workspaceFolder` with the absolute path where the OLake project is located on your system. For example:

<Tabs>
<TabItem value="mac_debug_path" label="macOS / Linux" default>
```json
"program": "/Users/john/Desktop/projects/olake/drivers/mongodb/main.go",
...
    "--config",
    "/Users/john/Desktop/projects/olake/drivers/mongodb/examples/source.json",
...          
```
</TabItem>
<TabItem value="win_debug_path" label="Windows">
```json
"program": "C:\\Users\\john\\Desktop\\projects\\olake\\drivers\\mongodb\\main.go",
...
    "--config",
    "C:\\Users\\john\\Desktop\\projects\\olake\\drivers\\mongodb\\examples\\source.json",
...          
```
</TabItem>
</Tabs>

:::tip
The `${workspaceFolder}` variable in the `launch.json` config automatically resolves to the correct path on any OS. You only need to update paths if you're not opening the OLake folder as your VS Code workspace.
:::
Now, set up debug points in the codebase and click "Launch Go Code".

![VS Code debugger paused on a breakpoint in Go code for OLake, with locals, call stack, and debug console outputs visible](/img/docs/getting-started/debug.webp)

### A Deep Dive into How to Debug OLake:

<YouTubeEmbed videoId="b7tQmWe3wmw" className="max-w-6xl" />


## 7. OLake UI Setup

**UI setup**: Please follow the setup instructions at [https://github.com/datazip-inc/olake-ui/](https://github.com/datazip-inc/olake-ui/)

