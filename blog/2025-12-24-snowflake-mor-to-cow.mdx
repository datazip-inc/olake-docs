---
slug: olake-mor-cow-databricks
title: "Bridging the Gap: Making OLake's MOR Iceberg Tables Compatible with Databrick's Query Engine"
description: Learn how to make OLake's Merge-on-Read (MOR) Iceberg tables compatible with Databricks using an automated MOR to COW write script that transforms MOR tables into Copy-on-Write (COW) format for accurate analytics queries.
tags: [iceberg, olake, databricks]
authors: [nayan]
image: /img/blog/2025/12/snowflake_cow.webp
--- 

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

If you're using OLake to replicate database changes to Apache Iceberg and Databricks for analytics, you've probably hit a frustrating roadblock: Databricks doesn't support equality delete files. OLake writes data efficiently using Merge-on-Read (MOR) with equality deletes for CDC operations, but when you try to query those tables in Databricks, the deletions, updates and inserts simply aren't honored. Your query results become incorrect, missing critical data changes.

This isn't just a Databricks limitation—several major query engines including Snowflake face the same challenge. While these platforms are incredibly powerful for analytics, their Iceberg implementations only support Copy-on-Write (COW) tables or position deletes at best.

In this blog, I'll walk you through the problem and show you how we've solved it with a simple yet powerful MOR to COW write script that transforms OLake's MOR tables into COW-compatible tables that Databricks and other query engines can read correctly.

## The Problem: MOR vs COW in the Real World

Let's understand what's happening under the hood. When you use OLake for Change Data Capture (CDC), it writes data to Iceberg using a strategy called Merge-on-Read (MOR) with equality delete files. This approach is optimized for high-throughput writes:

> **Note:** For a deeper understanding of MOR vs COW strategies in Apache Iceberg, refer to our detailed guide on [Merge-on-Read vs Copy-on-Write in Apache Iceberg](/iceberg/mor-vs-cow).

### How OLake Writes Data (MOR with Equality Deletes):

**1. Initial Full Refresh:** OLake performs a complete historical load of your table to Iceberg. This creates append only data files (No MOR).

**2. CDC Updates:** As changes happen in your source database, OLake captures them:
- New records → Written to new data files
- Updated records → Old version marked in an equality delete file, new version written to data file
- Deleted records → Marked in an equality delete file and soft-delete in the data-file

**3. The Result:** After multiple CDC sync cycles, you have:
- Multiple data files with your records
- Multiple equality delete files tracking which records should be ignored

## The Solution: Automated MOR to COW Write

The solution is to periodically compact your MOR tables into COW format—essentially creating a clean copy where all deletes and updates are fully applied by rewriting the data files. Think of it as "resolving" all the pending changes into a single, clean table state.

:::tip Storage Optimization
Once the COW table is created and verified, you can expire the MOR table data. To manage storage efficiently, run Iceberg's snapshot expiry job to expire snapshots older than 5-7 days, given that the compaction job runs daily. This eliminates data duplication and reduces storage costs.
::: 

We've built a PySpark script that automates this entire process. Here's how it works:

### Workflow  Overview

![MOR to COW compaction workflow](/img/blog/2025/12/snowflake_cow.webp)

The workflow consists of the following steps:

- **Data Ingestion**: Multiple source databases (PostgreSQL, MySQL, Oracle, MongoDB, Kafka) are ingested through OLake
- **MOR Table Creation**: OLake creates MOR-Equality-delete-tables
- **COW Write**: Spark script to transforms MOR tables into Copy-on-Write (COW) format by rewriting data files with equality deletes applied
- **Storage**: COW tables are stored in object storage (S3, Azure Blob Storage, GCS, etc.)
- **Querying**: Databricks queries COW tables as external Iceberg tables with all deletes and updates properly applied

### Prerequisites

Before running the MOR to COW write script, ensure you have the following installed:

- **Java 21**: Required for Spark runtime
- **Python 3.13.7**: Required for PySpark
- **Spark 3.5.2**: Apache Spark with Iceberg support

Additionally, make sure you have:
- Permission to access the Iceberg catalog
- Access to the object storage (S3, Azure Blob Storage, GCS, etc.) where your Iceberg tables are stored
- Appropriate cloud provider credentials or IAM roles configured

### Generate Destination Details

Before running the MOR to COW write script, you need to generate a `destination.json` file that contains your catalog configuration and credentials. This file is required as input for the write script.

<details>
<summary>View the destination details generation script</summary>

```bash
#!/bin/bash

# ============================================================================
# CONFIGURATION: Edit this section to customize the script
# ============================================================================

# API endpoint base URL
# Example: BASE_URL="http://localhost:8000"
#          BASE_URL="http://api.example.com"
BASE_URL="http://localhost:8000"

# OLake credentials
# Example: USERNAME="admin"
#          PASSWORD="your_password"
USERNAME="<YOUR_USERNAME>"
PASSWORD="<YOUR_PASSWORD>"

# Job ID to query (can also be provided as command line argument)
# Example: JOB_ID=157
# Usage: ./get_destination_destination.sh [job_id]
#        If job_id is provided as argument, it overrides this value
JOB_ID=9

# ============================================================================

# Check if jq is available
if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed. Please install jq to use this script."
    exit 1
fi

# Get job ID from command line argument if provided, otherwise use script variable
if [ -n "$1" ]; then
    JOB_ID="$1"
fi

# Check if job ID is specified
if [ -z "$JOB_ID" ] || [ "$JOB_ID" == "" ]; then
    echo "Error: Please specify a job ID either in the script (JOB_ID variable) or as a command line argument."
    echo "Usage: $0 [job_id]"
    exit 1
fi

# Login and save cookies
echo "Logging in to $BASE_URL..."
curl --location "$BASE_URL/login" \
  --header 'Content-Type: application/json' \
  --data "{
    \"username\": \"$USERNAME\",
    \"password\": \"$PASSWORD\"
  }" \
  -c cookies.txt \
  -s > /dev/null

# Get jobs data and save to temporary file
echo "Fetching jobs data for job ID: $JOB_ID..."
RESPONSE_FILE=$(mktemp)
curl --location "$BASE_URL/api/v1/project/123/jobs" \
  --header 'Content-Type: application/json' \
  -b cookies.txt \
  -s > "$RESPONSE_FILE"

# Extract and save destination.config as parsed JSON (single object, not array)
OUTPUT_FILE="destination.json"
jq -r ".data[]? | select(.id == $JOB_ID) | 
  .destination.config // \"\" |
  if type == \"string\" and length > 0 then
    fromjson
  else
    {}
  end" "$RESPONSE_FILE" 2>/dev/null > "$OUTPUT_FILE"

echo "Results saved to: $OUTPUT_FILE"

# Cleanup
rm -f "$RESPONSE_FILE" cookies.txt
```

</details>

**Before running the script, update the following configuration:**

- **`BASE_URL`**: Replace with your OLake API endpoint URL (e.g., `http://localhost:8000` or your production API URL)
- **`USERNAME`**: Replace `<YOUR_USERNAME>` with your OLake username
- **`PASSWORD`**: Replace `<YOUR_PASSWORD>` with your OLake password
- **`JOB_ID`**: Replace with your actual job ID. The job ID can be obtained from the OLake UI job section. This job ID is required to retrieve the catalog configuration, URIs, and credentials from `destination.json` for all tables synced by that job.

**To run the script:**

1. Save the script to a file (e.g., `get_destination_details.sh`) in your desired directory
2. Navigate to the directory where you saved the script:
   ```bash
   cd /path/to/your/script/directory
   ```
3. Make the script executable (if needed):
   ```bash
   chmod +x get_destination_details.sh
   ```
4. Run the script:
   ```bash
   bash get_destination_details.sh
   ```
   Or if you made it executable:
   ```bash
   ./get_destination_details.sh
   ```
   You can also pass the job ID as a command line argument:
   ```bash
   ./get_destination_details.sh <job_id>
   ```

The script will generate a `destination.json` file that contains the catalog configuration, credentials, and object storage settings needed by the MOR to COW write script. This file is automatically used by the write script to configure the Spark session with the correct Iceberg catalog and storage credentials.

### MOR to COW Write Script

<details>
<summary>View the PySpark MOR to COW write script</summary>

```python
import argparse
import json
import os
from typing import Optional

from pyspark.sql import SparkSession
from pyspark.sql.utils import AnalysisException

# Spark session is created in __main__ after we parse destination config.
spark = None  # type: ignore[assignment]

# ------------------------------------------------------------------------------
# User Inputs (must be provided)
# ------------------------------------------------------------------------------
CATALOG = "olake_iceberg"
# Source namespace/database for MOR tables.
# User must hardcode this before running the script.
DB = "<NAME_OF_YOUR_SOURCE_DATABASE>"
# Destination namespace/database for generated COW tables (same catalog, different db)
COW_DB = "<NAME_OF_YOUR_COW_DATABASE>"

# Base S3 location where per-table COW tables (and the shared state table) will be stored.
# Example: "s3://my-bucket/warehouse/cow"
COW_BASE_LOCATION = "<YOUR_COW_BASE_LOCATION>"

# Shared state table (single Iceberg table with one row per MOR table).
#
# We no longer use a shared state table. Instead, we store per-table checkpoint state
# in the COW table's Iceberg table properties (custom metadata).
#
# Property key used to store the last successfully processed truncate boundary snapshot id.
COW_CHECKPOINT_PROPERTY_KEY = "cow.last_success_truncate_snapshot_id"

PRIMARY_KEY = "_olake_id"


def _recompute_derived_names():
    # No derived names needed for state-table anymore.
    return


def load_destination_writer_config(destination_details_path: str, job_id: Optional[int] = None) -> dict:
    
    with open(destination_details_path, "r", encoding="utf-8") as f:
        outer = json.load(f)

    # New simplified format: top-level dict with writer
    if isinstance(outer, dict) and isinstance(outer.get("writer"), dict):
        writer = outer.get("writer")
        assert isinstance(writer, dict)
        return writer

    # Old format: array of records
    if not isinstance(outer, list) or not outer:
        raise ValueError("Destination config file must be either a JSON object with 'writer' or a non-empty JSON array")

    record = None
    if job_id is None:
        record = outer[0]
    else:
        for r in outer:
            if r.get("job_id") == job_id:
                record = r
                break
        if record is None:
            raise ValueError(f"job_id {job_id} not found in destination_details.json")

    dest = record.get("destination") or {}
    config_str = dest.get("config")
    if not config_str:
        raise ValueError("destination.config missing in destination_details.json")

    inner = json.loads(config_str)
    writer = inner.get("writer")
    if not isinstance(writer, dict):
        raise ValueError("destination.config JSON does not contain a 'writer' object")
    return writer


def _normalize_warehouse(catalog_type: str, warehouse_val: str) -> str:
    """
    - REST/Lakekeeper: warehouse can be a Lakekeeper 'warehouse name' (not a URI).
    - Glue/JDBC: warehouse must be a filesystem URI/path (often s3a://bucket/prefix).
    """
    if not warehouse_val:
        raise ValueError("iceberg_s3_path is required")

    v = warehouse_val.strip()

    if catalog_type == "rest":
        return v

    # For glue/jdbc, accept s3:// or s3a://; if no scheme, assume it's "bucket/prefix"
    if v.startswith("s3://"):
        return "s3a://" + v[len("s3://") :]
    if v.startswith("s3a://"):
        return v
    return "s3a://" + v.lstrip("/")


def _spark_packages_for(writer: dict, catalog_type: str) -> str:
    """
    Base packages are required for Iceberg + S3. JDBC catalogs additionally need a DB driver.
    """
    pkgs = [
        "org.apache.iceberg:iceberg-spark-runtime-3.5_2.12:1.5.2",
        "org.apache.iceberg:iceberg-aws-bundle:1.5.2",
        "org.apache.hadoop:hadoop-aws:3.3.4",
        "com.amazonaws:aws-java-sdk-bundle:1.12.262",
    ]

    if catalog_type == "jdbc":
        jdbc_url = (writer.get("jdbc_url") or "").lower()
        # Common case for Iceberg JDBC catalog
        if jdbc_url.startswith("jdbc:postgresql:"):
            pkgs.append("org.postgresql:postgresql:42.5.4")
        elif jdbc_url.startswith("jdbc:mysql:"):
            pkgs.append("mysql:mysql-connector-java:8.0.33")

    # de-dupe while preserving order
    seen = set()
    out = []
    for p in pkgs:
        if p not in seen:
            seen.add(p)
            out.append(p)
    return ",".join(out)


def build_spark_session_from_writer(writer: dict) -> SparkSession:
    catalog_type = (writer.get("catalog_type") or "").lower()
    catalog_name = writer.get("catalog_name") or CATALOG
    warehouse_raw = writer.get("iceberg_s3_path") or ""
    warehouse = _normalize_warehouse(catalog_type, warehouse_raw)

    # S3A settings
    s3_endpoint = writer.get("s3_endpoint")
    aws_region = writer.get("aws_region")
    aws_access_key = writer.get("aws_access_key")
    aws_secret_key = writer.get("aws_secret_key")
    aws_session_token = (
        writer.get("aws_session_token")
        or writer.get("aws_sessionToken")
        or writer.get("session_token")
        or writer.get("sessionToken")
    )
    s3_path_style = writer.get("s3_path_style")  # may not exist; we'll infer if missing
    s3_use_ssl = writer.get("s3_use_ssl")

    # Infer path-style for MinIO-like endpoints if not specified
    if s3_path_style is None and isinstance(s3_endpoint, str):
        if s3_endpoint.startswith("http://") or "9000" in s3_endpoint or "minio" in s3_endpoint.lower():
            s3_path_style = True
    if s3_path_style is None:
        s3_path_style = True

    # Infer SSL from endpoint scheme if present; allow explicit override via s3_use_ssl
    ssl_enabled = None
    if isinstance(s3_use_ssl, bool):
        ssl_enabled = "true" if s3_use_ssl else "false"
    if isinstance(s3_endpoint, str) and s3_endpoint.startswith("http://"):
        ssl_enabled = ssl_enabled or "false"
    elif isinstance(s3_endpoint, str) and s3_endpoint.startswith("https://"):
        ssl_enabled = ssl_enabled or "true"

    # Maven packages (network is available per your note)
    packages = _spark_packages_for(writer, catalog_type)

    builder = SparkSession.builder.appName("OLake MOR to COW Compaction")
    builder = builder.config("spark.jars.packages", packages)
    builder = builder.config(
        "spark.sql.extensions",
        "org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions",
    )
    builder = builder.config("spark.sql.catalogImplementation", "in-memory")
    builder = builder.config("spark.sql.defaultCatalog", catalog_name)

    # Ensure AWS SDK-based clients (e.g., GlueCatalog, Iceberg S3FileIO) can see credentials.
    # This avoids requiring users to export env vars in the container.
    if aws_region:
        os.environ["AWS_REGION"] = str(aws_region)
        os.environ["AWS_DEFAULT_REGION"] = str(aws_region)
        builder = builder.config("spark.driverEnv.AWS_REGION", str(aws_region))
        builder = builder.config("spark.driverEnv.AWS_DEFAULT_REGION", str(aws_region))
        builder = builder.config("spark.executorEnv.AWS_REGION", str(aws_region))
        builder = builder.config("spark.executorEnv.AWS_DEFAULT_REGION", str(aws_region))
    if aws_access_key and aws_secret_key:
        os.environ["AWS_ACCESS_KEY_ID"] = str(aws_access_key)
        os.environ["AWS_SECRET_ACCESS_KEY"] = str(aws_secret_key)
        builder = builder.config("spark.driverEnv.AWS_ACCESS_KEY_ID", str(aws_access_key))
        builder = builder.config("spark.driverEnv.AWS_SECRET_ACCESS_KEY", str(aws_secret_key))
        builder = builder.config("spark.executorEnv.AWS_ACCESS_KEY_ID", str(aws_access_key))
        builder = builder.config("spark.executorEnv.AWS_SECRET_ACCESS_KEY", str(aws_secret_key))
    if aws_session_token:
        os.environ["AWS_SESSION_TOKEN"] = str(aws_session_token)
        builder = builder.config("spark.driverEnv.AWS_SESSION_TOKEN", str(aws_session_token))
        builder = builder.config("spark.executorEnv.AWS_SESSION_TOKEN", str(aws_session_token))

    # SparkCatalog wrapper
    builder = builder.config(f"spark.sql.catalog.{catalog_name}", "org.apache.iceberg.spark.SparkCatalog")
    builder = builder.config(f"spark.sql.catalog.{catalog_name}.io-impl", "org.apache.iceberg.aws.s3.S3FileIO")
    builder = builder.config(f"spark.sql.catalog.{catalog_name}.warehouse", warehouse)

    # IMPORTANT: Iceberg's S3FileIO uses AWS SDK directly (not Hadoop S3A configs).
    # For MinIO/non-AWS endpoints, set Iceberg catalog-level s3.* properties so
    # metadata/data writes go to the correct endpoint.
    builder = builder.config(
        f"spark.sql.catalog.{catalog_name}.s3.path-style-access",
        str(bool(s3_path_style)).lower(),
    )
    if s3_endpoint:
        builder = builder.config(f"spark.sql.catalog.{catalog_name}.s3.endpoint", s3_endpoint)
    if aws_region:
        builder = builder.config(f"spark.sql.catalog.{catalog_name}.s3.region", aws_region)
    if aws_access_key and aws_secret_key:
        builder = builder.config(f"spark.sql.catalog.{catalog_name}.s3.access-key-id", aws_access_key)
        builder = builder.config(f"spark.sql.catalog.{catalog_name}.s3.secret-access-key", aws_secret_key)

    # Catalog impl specifics
    if catalog_type == "rest":
        rest_url = writer.get("rest_catalog_url")
        if not rest_url:
            raise ValueError("rest_catalog_url is required for catalog_type=rest")
        builder = builder.config(f"spark.sql.catalog.{catalog_name}.catalog-impl", "org.apache.iceberg.rest.RESTCatalog")
        builder = builder.config(f"spark.sql.catalog.{catalog_name}.uri", rest_url)
    elif catalog_type == "glue":
        builder = builder.config(
            f"spark.sql.catalog.{catalog_name}.catalog-impl",
            "org.apache.iceberg.aws.glue.GlueCatalog",
        )
        # Optional: Glue catalog id/account id if provided
        glue_catalog_id = writer.get("glue_catalog_id") or writer.get("glue.catalog-id") or writer.get("catalog_id")
        if glue_catalog_id:
            builder = builder.config(f"spark.sql.catalog.{catalog_name}.glue.catalog-id", str(glue_catalog_id))
        # Region can be needed by AWS SDK for Glue
        if aws_region:
            builder = builder.config(
                "spark.driver.extraJavaOptions",
                f"-Daws.region={aws_region} -Daws.defaultRegion={aws_region}",
            )
            builder = builder.config(
                "spark.executor.extraJavaOptions",
                f"-Daws.region={aws_region} -Daws.defaultRegion={aws_region}",
            )
    elif catalog_type == "jdbc":
        jdbc_url = writer.get("jdbc_url")
        if not jdbc_url:
            raise ValueError("jdbc_url is required for catalog_type=jdbc")
        builder = builder.config(
            f"spark.sql.catalog.{catalog_name}.catalog-impl",
            "org.apache.iceberg.jdbc.JdbcCatalog",
        )
        builder = builder.config(f"spark.sql.catalog.{catalog_name}.uri", jdbc_url)

        jdbc_user = writer.get("jdbc_username") or writer.get("jdbc_user") or writer.get("username")
        jdbc_password = writer.get("jdbc_password") or writer.get("jdbc_pass") or writer.get("password")
        if jdbc_user:
            builder = builder.config(f"spark.sql.catalog.{catalog_name}.jdbc.user", str(jdbc_user))
        if jdbc_password:
            builder = builder.config(f"spark.sql.catalog.{catalog_name}.jdbc.password", str(jdbc_password))
    else:
        raise ValueError(f"Unsupported catalog_type={catalog_type}. Supported: rest, glue, jdbc")

    # S3A filesystem settings
    builder = builder.config("spark.hadoop.fs.s3a.impl", "org.apache.hadoop.fs.s3a.S3AFileSystem")
    builder = builder.config("spark.hadoop.fs.s3a.path.style.access", str(bool(s3_path_style)).lower())

    if s3_endpoint:
        builder = builder.config("spark.hadoop.fs.s3a.endpoint", s3_endpoint)
    if aws_region:
        builder = builder.config("spark.hadoop.fs.s3a.region", aws_region)
    if ssl_enabled is not None:
        builder = builder.config("spark.hadoop.fs.s3a.connection.ssl.enabled", ssl_enabled)

    if aws_access_key and aws_secret_key:
        builder = builder.config(
            "spark.hadoop.fs.s3a.aws.credentials.provider",
            "org.apache.hadoop.fs.s3a.SimpleAWSCredentialsProvider",
        )
        builder = builder.config("spark.hadoop.fs.s3a.access.key", aws_access_key)
        builder = builder.config("spark.hadoop.fs.s3a.secret.key", aws_secret_key)

    return builder.getOrCreate()


# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------
def split_fqn(table_fqn: str):
    parts = table_fqn.split(".")
    if len(parts) != 3:
        raise ValueError(f"Expected table fqn as <catalog>.<db>.<table>, got: {table_fqn}")
    return parts[0], parts[1], parts[2]


def cow_table_and_location_for(mor_table_fqn: str):
    catalog, _db, table = split_fqn(mor_table_fqn)
    cow_table_fqn = f"{catalog}.{COW_DB}.{table}_cow"
    cow_location = f"{COW_BASE_LOCATION}/{table}_cow"
    return cow_table_fqn, cow_location


def table_exists(table_name: str) -> bool:
    try:
        spark.read.format("iceberg").load(table_name).limit(1).collect()
        return True
    except AnalysisException:
        return False


def ensure_namespace_exists(catalog: str, namespace: str):
    # Create destination namespace for COW tables/state if missing.
    # Iceberg SparkCatalog supports CREATE NAMESPACE for REST/Glue catalogs.
    spark.sql(f"CREATE NAMESPACE IF NOT EXISTS {catalog}.{namespace}")


def get_cow_checkpoint_truncate_snapshot_id(cow_table_fqn: str) -> Optional[int]:
    """
    Read checkpoint from the COW table's properties.
    Returns the last successfully processed truncate boundary snapshot id (int) or None.
    """
    if not table_exists(cow_table_fqn):
        return None
    try:
        rows = spark.sql(f"SHOW TBLPROPERTIES {cow_table_fqn}").collect()
    except Exception:
        return None
    for r in rows:
        d = r.asDict(recursive=True)
        k = d.get("key") or d.get("property") or d.get("k")
        v = d.get("value") or d.get("v")
        if k == COW_CHECKPOINT_PROPERTY_KEY and v is not None:
            try:
                return int(str(v))
            except Exception:
                return None
    return None


def set_cow_checkpoint_truncate_snapshot_id(cow_table_fqn: str, truncate_snapshot_id: int):
    """
    Persist checkpoint into COW table properties after successful compaction of boundary.
    """
    spark.sql(
        f"ALTER TABLE {cow_table_fqn} SET TBLPROPERTIES ('{COW_CHECKPOINT_PROPERTY_KEY}' = '{truncate_snapshot_id}')"
    )


# ------------------------------------------------------------------------------
# Iceberg snapshot helpers
# ------------------------------------------------------------------------------
def get_latest_snapshot_and_parent_id(table_fqn: str):
    rows = spark.sql(f"""
        SELECT snapshot_id, parent_id
        FROM {table_fqn}.snapshots
        ORDER BY committed_at DESC
        LIMIT 1
    """).collect()
    if not rows:
        return None, None
    return rows[0]["snapshot_id"], rows[0]["parent_id"]


def _summary_int(summary: Optional[dict], key: str) -> Optional[int]:
    if not summary or key not in summary:
        return None
    try:
        return int(summary.get(key))  # type: ignore[arg-type]
    except Exception:
        return None


def _added_delete_files(summary: Optional[dict]) -> int:
    """
    Best-effort: different engines/versions may emit different keys.
    Treat missing keys as 0.
    """
    if not summary:
        return 0
    for k in ("added-delete-files", "added-equality-delete-files", "added-position-delete-files"):
        v = _summary_int(summary, k)
        if v is not None and v != 0:
            return v
    # If keys exist but are '0', return 0.
    return 0


def _removed_data_files(summary: Optional[dict]) -> Optional[int]:
    """
    Best-effort: removal count is sometimes stored as 'deleted-data-files' (Iceberg metrics),
    and sometimes as other keys depending on engine.
    """
    for k in ("deleted-data-files", "removed-data-files", "deleted_files", "removed_files"):
        v = _summary_int(summary, k)
        if v is not None:
            return v
    return None


def _is_truncate_boundary_snapshot(snap: dict, parent: Optional[dict]) -> bool:
    """
    Identify compaction boundary snapshots created by TRUNCATE TABLE.

    - operation == 'delete'
    - added-data-files == 0
    - added delete files == 0
    - total-data-files == 0 (table empty after boundary)
    - removed/deleted data files == parent.total-data-files
    """
    if (snap.get("operation") or "").lower() != "delete":
        return False

    summary = snap.get("summary") or {}
    parent_summary = (parent or {}).get("summary") or {}

    added_data_files = _summary_int(summary, "added-data-files") or 0
    if added_data_files != 0:
        return False

    if _added_delete_files(summary) != 0:
        return False

    total_data_files = _summary_int(summary, "total-data-files")
    if total_data_files is not None and total_data_files != 0:
        return False

    removed = _removed_data_files(summary)
    parent_total = _summary_int(parent_summary, "total-data-files")
    if removed is not None and parent_total is not None:
        return removed == parent_total

    # Fallback if one side isn't available: delete-to-empty should remove something.
    if removed is not None:
        return removed > 0
    return False


def _load_snapshots_with_summary(table_fqn: str):
    """
    Returns a list of dicts with keys: snapshot_id, parent_id, committed_at, operation, summary.
    Sorted by committed_at ascending (oldest -> newest).
    """
    rows = spark.sql(f"""
        SELECT snapshot_id, parent_id, committed_at, operation, summary
        FROM {table_fqn}.snapshots
        ORDER BY committed_at ASC
    """).collect()
    out = []
    for r in rows:
        d = r.asDict(recursive=True)
        out.append(
            {
                "snapshot_id": d.get("snapshot_id"),
                "parent_id": d.get("parent_id"),
                "committed_at": d.get("committed_at"),
                "operation": d.get("operation"),
                "summary": d.get("summary"),
            }
        )
    return out


def _find_truncate_boundaries(table_fqn: str):
    """
    Return truncate boundary snapshots (oldest -> newest) detected via operation+summary signature.
    """
    snaps = _load_snapshots_with_summary(table_fqn)
    by_id = {s["snapshot_id"]: s for s in snaps}
    boundaries = []
    for s in snaps:
        parent = by_id.get(s.get("parent_id"))
        if _is_truncate_boundary_snapshot(s, parent):
            boundaries.append(s)
    return boundaries, by_id

# ------------------------------------------------------------------------------
# Merge + schema alignment
# ------------------------------------------------------------------------------
def align_cow_schema(cow_table_fqn: str, mor_df, cow_df):
    mor_schema = {f.name: f.dataType for f in mor_df.schema.fields}
    cow_schema = {f.name: f.dataType for f in cow_df.schema.fields}

    for col, dtype in mor_schema.items():
        if col not in cow_schema:
            print(f"Adding new column '{col}' with type '{dtype.simpleString()}' to COW table")
            spark.sql(f"""
                ALTER TABLE {cow_table_fqn}
                ADD COLUMN {col} {dtype.simpleString()}
            """)

    for col, mor_type in mor_schema.items():
        if col in cow_schema:
            cow_type = cow_schema[col]
            if mor_type != cow_type:
                print(
                    f"Updating column '{col}' type from '{cow_type.simpleString()}' "
                    f"to '{mor_type.simpleString()}' in COW table"
                )
                spark.sql(f"""
                    ALTER TABLE {cow_table_fqn}
                    ALTER COLUMN {col} TYPE {mor_type.simpleString()}
                """)


def merge_snapshot_into_cow(mor_table_fqn: str, cow_table_fqn: str, snapshot_id: int):
    mor_df = (
        spark.read.format("iceberg")
        .option("snapshot-id", snapshot_id)
        .load(mor_table_fqn)
    )
    cow_df = spark.read.format("iceberg").load(cow_table_fqn)

    align_cow_schema(cow_table_fqn, mor_df, cow_df)

    spark.sql(f"""
        MERGE INTO {cow_table_fqn} AS target
        USING (
            SELECT *
            FROM {mor_table_fqn}
            VERSION AS OF {snapshot_id}
        ) AS source
        ON target.{PRIMARY_KEY} = source.{PRIMARY_KEY}

        WHEN MATCHED THEN
            UPDATE SET *

        WHEN NOT MATCHED THEN
            INSERT *
    """)


def run_compaction_cycle_for_table(mor_table_fqn: str):
    cow_table_fqn, cow_location = cow_table_and_location_for(mor_table_fqn)
    cow_exists = table_exists(cow_table_fqn)
    # Step 1/2: Read last successful truncate checkpoint from COW table properties.
    last_success_t = get_cow_checkpoint_truncate_snapshot_id(cow_table_fqn)
    if last_success_t is None:
        print(f"[{mor_table_fqn}] No COW checkpoint found; starting from earliest MOR history.")
    else:
        print(f"[{mor_table_fqn}] Last successful truncate checkpoint from COW metadata: {last_success_t}")

    # Step 3: Truncate MOR to create the current boundary for this run.
    spark.sql(f"TRUNCATE TABLE {mor_table_fqn}")

    truncate_snapshot_id, high_water_snapshot_id = get_latest_snapshot_and_parent_id(mor_table_fqn)
    print(f"[{mor_table_fqn}] Boundary truncate snapshot: {truncate_snapshot_id}")
    print(f"[{mor_table_fqn}] High-water (pre-truncate) snapshot: {high_water_snapshot_id}")

    # Step 4: Find truncate boundaries in MOR history up to the current truncate.
    boundaries, by_id = _find_truncate_boundaries(mor_table_fqn)
    current_t_snap = by_id.get(truncate_snapshot_id)
    current_t_ts = current_t_snap.get("committed_at") if current_t_snap else None

    if last_success_t is None:
        last_ts = None
    else:
        last_snap = by_id.get(last_success_t)
        last_ts = last_snap.get("committed_at") if last_snap else None

    to_process = []
    for b in boundaries:
        bt = b.get("committed_at")
        if current_t_ts is not None and bt is not None and bt > current_t_ts:
            continue
        if last_ts is not None and bt is not None and bt <= last_ts:
            continue
        to_process.append(b)

    # Ensure the current truncate is included as the end boundary for this run (if detected).
    if truncate_snapshot_id is not None and all(x.get("snapshot_id") != truncate_snapshot_id for x in to_process):
        # If current truncate isn't detected by signature, we still process the latest high-water once.
        # (Per requirements, we ignore the concurrency race for now.)
        if high_water_snapshot_id is None:
            print(f"[{mor_table_fqn}] Nothing to compact (no high-water snapshot).")
            if not cow_exists:
                print(f"[{mor_table_fqn}] Creating empty COW table...")
                spark.sql(f"""
                    CREATE TABLE {cow_table_fqn}
                    USING iceberg
                    LOCATION '{cow_location}'
                    AS
                    SELECT *
                    FROM {mor_table_fqn}
                """)
                cow_exists = True
            if truncate_snapshot_id is not None:
                set_cow_checkpoint_truncate_snapshot_id(cow_table_fqn, int(truncate_snapshot_id))
            return

        # First-time: create COW baseline from the high-water snapshot (CTAS).
        if not cow_exists:
            print(f"[{mor_table_fqn}] Creating COW baseline from snapshot {high_water_snapshot_id} ...")
            spark.sql(f"""
                CREATE TABLE {cow_table_fqn}
                USING iceberg
                LOCATION '{cow_location}'
                AS
                SELECT *
                FROM {mor_table_fqn}
                VERSION AS OF {high_water_snapshot_id}
            """)
            cow_exists = True
        else:
            print(f"[{mor_table_fqn}] Compacting snapshot {high_water_snapshot_id} into existing COW ...")
            merge_snapshot_into_cow(mor_table_fqn, cow_table_fqn, int(high_water_snapshot_id))

        set_cow_checkpoint_truncate_snapshot_id(cow_table_fqn, int(truncate_snapshot_id))
        print(f"[{mor_table_fqn}] Updated COW checkpoint to truncate {truncate_snapshot_id}.")
        return

    if not to_process:
        print(f"[{mor_table_fqn}] No truncate boundaries to process in this run.")
        if truncate_snapshot_id is not None:
            set_cow_checkpoint_truncate_snapshot_id(cow_table_fqn, int(truncate_snapshot_id))
        return

    # Step 5: For each boundary, compact its parent snapshot, then update COW checkpoint property.
    boundary_ids = {b.get("snapshot_id") for b in boundaries}
    for b in to_process:
        t_id = b.get("snapshot_id")
        h_id = b.get("parent_id")
        print(f"[{mor_table_fqn}] Processing boundary {t_id}; parent(high-water)={h_id}")

        if h_id is None:
            # Nothing existed before this boundary; ensure COW exists (empty) and checkpoint boundary.
            if not cow_exists:
                print(f"[{mor_table_fqn}] Creating empty COW table (no parent snapshot exists)...")
                spark.sql(f"""
                    CREATE TABLE {cow_table_fqn}
                    USING iceberg
                    LOCATION '{cow_location}'
                    AS
                    SELECT *
                    FROM {mor_table_fqn}
                    VERSION AS OF {t_id}
                """)
                cow_exists = True
            if t_id is not None:
                set_cow_checkpoint_truncate_snapshot_id(cow_table_fqn, int(t_id))
                print(f"[{mor_table_fqn}] Updated COW checkpoint to truncate {t_id}.")
            continue

        # Skip if the parent is itself a truncate boundary (avoid compacting empty boundary artifacts).
        if h_id in boundary_ids:
            print(f"[{mor_table_fqn}] Skipping parent snapshot {h_id} because it is also a truncate boundary.")
            if t_id is not None:
                set_cow_checkpoint_truncate_snapshot_id(cow_table_fqn, int(t_id))
            continue

        if not cow_exists:
            print(f"[{mor_table_fqn}] COW table missing; creating baseline from snapshot {h_id} ...")
            spark.sql(f"""
                CREATE TABLE {cow_table_fqn}
                USING iceberg
                LOCATION '{cow_location}'
                AS
                SELECT *
                FROM {mor_table_fqn}
                VERSION AS OF {h_id}
            """)
            cow_exists = True
        else:
            print(f"[{mor_table_fqn}] Compacting snapshot {h_id} into existing COW ...")
            merge_snapshot_into_cow(mor_table_fqn, cow_table_fqn, int(h_id))

        if t_id is not None:
            set_cow_checkpoint_truncate_snapshot_id(cow_table_fqn, int(t_id))
            print(f"[{mor_table_fqn}] Updated COW checkpoint to truncate {t_id}.")


def list_tables_in_db(catalog: str, db: str):
    rows = spark.sql(f"SHOW TABLES IN {catalog}.{db}").collect()
    table_names = []
    for r in rows:
        d = r.asDict(recursive=True)
        if d.get("isTemporary", False):
            continue
        name = d.get("tableName") or d.get("table")
        if name:
            table_names.append(name)
    return table_names


# ------------------------------------------------------------------------------
# Entry Point
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MOR -> COW compaction (REST Lakekeeper / Glue), configured from destination_details.json")
    parser.add_argument(
        "--destination-details",
        required=True,
        help="Path to destination_details.json generated by get_destination_details.sh",
    )
    parser.add_argument("--job-id", type=int, default=None, help="Optional job_id to select from destination_details.json")
    parser.add_argument("--cow-db", default=COW_DB, help="Destination namespace/database for COW tables/state")
    parser.add_argument("--catalog-name", default=None, help="Override catalog name (otherwise taken from destination config)")
    args = parser.parse_args()

    # Source DB is expected to be hardcoded in this file.
    if not DB or DB.strip() == "" or DB.strip() == "<YOUR_SOURCE_DB>":
        raise ValueError("Please set DB = '<YOUR_SOURCE_DB>' at the top of fail_test.py before running.")

    # Update globals from args
    COW_DB = args.cow_db

    writer = load_destination_writer_config(args.destination_details, job_id=args.job_id)
    if args.catalog_name:
        writer["catalog_name"] = args.catalog_name

    # Update catalog name global (used in derived FQNs)
    CATALOG = writer.get("catalog_name") or CATALOG
    _recompute_derived_names()

    # Create Spark session with the right Iceberg/S3 config
    spark = build_spark_session_from_writer(writer)

    # Ensure destination namespace exists before creating state/COW tables
    ensure_namespace_exists(CATALOG, COW_DB)

    # Always compact all MOR tables in the source namespace/database.
    all_tables = list_tables_in_db(CATALOG, DB)
    mor_tables = [
        f"{CATALOG}.{DB}.{t}"
        for t in all_tables
        if not t.endswith("_cow")
    ]

    successes = []
    failures = []

    for mor_table in mor_tables:
        try:
            run_compaction_cycle_for_table(mor_table)
            successes.append(mor_table)
        except Exception as e:
            failures.append((mor_table, str(e)))
            print(f"[{mor_table}] FAILED: {e}")

    print("---- Compaction Summary ----")
    print(f"Successful tables: {len(successes)}")
    for t in successes:
        print(f"  - {t}")
    print(f"Failed tables: {len(failures)}")
    for t, err in failures:
        print(f"  - {t}: {err}")



```

</details>

**Before running the script, make sure to update the following variables in the "User Inputs" section:**
- **`COW_DB`**: Replace `<NAME_OF_YOUR_COW_DATABASE>` with the namespace/database where COW tables + the state table should live (e.g., `postgres_main_public_cow`)
- **`COW_BASE_LOCATION`**: Replace `<YOUR_COW_BASE_LOCATION>` with the base object-storage path where COW tables will be written (e.g., `s3://my-bucket/warehouse/cow`)
- **`DB`**: Replace `<NAME_OF_YOUR_SOURCE_DATABASE>` with the namespace/database containing the MOR tables to be converted to COW format.

:::note Lakekeeper Limitation
For Lakekeeper catalogs, `COW_BASE_LOCATION` must be within the warehouse location. You can use a subfolder (e.g., if warehouse is `s3://bucket/warehouse`, use `s3://bucket/warehouse/cow`).
:::

**To execute the MOR to COW write script, use the following spark-submit command:**

```bash
spark-submit \
  --master 'local[*]' \
  compaction_script.py \
  --destination-details destination.json
```

Replace `compaction_script.py` with the actual name of your MOR to COW write script file. The script will automatically read the catalog configuration, credentials, and object storage settings from the `destination.json` file generated by the previous step.


### How the MOR to COW Write Script Works

The MOR to COW write process is designed to be safe, repeatable, and compatible with continuous CDC ingestion. Key features:

- **Non-intrusive**: Works alongside OLake's ongoing syncs using Iceberg's snapshot isolation
- **Unified incremental mode**: Uses a single function that handles both first-time and subsequent runs. On the first run, it checks if the COW table exists—if not, it creates the COW table with a full resolved dataset from the MOR table. On subsequent runs, it updates the existing COW table with only the latest changes.

**1. Read the last successful truncate ID from the COW table:** The process starts by checking the COW table metadata to determine whether a previous MOR → COW run has completed successfully.
- The metadata is scanned to find the last snapshot ID that was explicitly marked as a successful truncate.
- If no COW table exists, or if the table exists but no truncate snapshot is recorded, the system treats this as a first-time run.

This step defines from where the next processing should begin.

**2. Decide the starting snapshot in the MOR table:** Based on the outcome of **Step 1**:
- If it is a First Run (no COW table exists/no truncate snapshot is recorded), the script starts from the earliest snapshot in the MOR table.
- If it is a Subsequent Run (COW table exists/truncate snapshot is recorded), the script starts from the next snapshot after the last successful truncate.

This ensures the process never reprocesses already-handled data.

**3. Truncate the MOR table to mark the current boundary:** Before any data is merged, the MOR table is explicitly truncated.
- This truncate operation creates a new snapshot, which serves as the upper boundary for the current processing cycle.
- This truncate snapshot marks the end point up to which MOR data should be processed in this run.

At this point, the workflow has a **starting point** obtained from **Step 2** and an **ending point** obtained from this newly created truncate.

**4. Iterate through MOR snapshots and detect truncate boundaries:** The workflow now walks through MOR snapshots sequentially, starting from the snapshot chosen in **Step 2** and stopping at the truncate snapshot created in **Step 3**. During this iteration:
- Each snapshot is examined to determine whether it represents a truncate operation.
- Truncate snapshots are detected using metadata signals such as:
    - `operation` = `overwrite`
    - `added-data-files` = 0
    - `added-delete-files` = 0
    - `total-data-files` = 0
    - `removed-data-files` = `previous_snapshot.total-data-files`

This allows the workflow to correctly identify all truncate points, including those created in previous failed runs.

**5. Prepare COW database, table, and schema:** Before any data transfer happens, the workflow prepares the COW side completely.
- If this is the first run, the COW database is created if it does not exist. The COW table is created with the required structure as of the MOR table.
- If the COW table already exists, the MOR schema is compared with the COW schema. If there are any schema changes or new tables are added, the COW table is altered to match the MOR table schema.

This step guarantees that the COW table is fully ready and schema-compatible before any transfer begins.

**6. Merge MOR data into the COW table:** Once the COW table and schema are prepared, the workflow transfers data for the current snapshot range.
- If it is a **First Time Transfer**, a **CTAS (Create Table As Select)** is used to write the initial resolved dataset from MOR into COW.
- If it is a **Subsequent Transfer**, a **MERGE INTO** statement is used to transfer the data from MOR to COW.
- Before transferring we check that if a truncate snapshot's parent snapshot is also a truncate? If yes, it is skipped to avoid redundant processing.
- After the transfer is completed successfully, the corresponding truncate snapshot ID is written to the COW table metadata as a checkpoint.
- This process is repeated for every truncate snapshot in the list until the final truncate snapshot is processed.

### Failure Recovery and State Management

<details>
<summary>View failure recovery and state management details</summary>


The MOR to COW write flow is designed to be safe to re-run by checkpointing progress only after a truncate cycle is fully and successfully transferred.

The workflow records successful truncate snapshot IDs directly in the COW table metadata and replays any missing truncate cycles when a failure occurs.

`eq1 → eq2 → eq3 → eq4 → trunc1 → eq5 → eq6 → eq7 → trunc2`

Here:
- `eq*` snapshots contain cdc changes
- `trunc*` snapshots mark truncate boundaries 

#### What the state table stores

For each MOR table its corresponding COW table stores:
- `**last_successful_truncate_snapshot_id**`: The most recent truncate snapshot that has been fully merged into the COW table (e.g., `trunc1`, `trunc2`)

On reruns, the script uses `last_successful_truncate_snapshot_id` as the effective checkpoint.

#### How recovery works

1. **Cycle around `trunc1`:**
   - The script checks the present COW table for last successful truncate snapshot ID. Since its not present it starts from the earliest snapshot in the MOR table.
   - The script truncates the MOR table (creating `trunc1`)
   - It finds the predecessor snapshot (the snapshot before truncate): `eq4`
   - It merges `eq4` into the COW table
   - Only after the merge succeeds, it updates COW table metadata:
     - `last_successful_truncate_snapshot_id = trunc1`

2. **Cycle around `trunc2`:**

   Suppose the script truncates again and tries to merge `eq7`, but the run fails. In this case the script will not update the COW table metadata and will continue to use the `last_successful_truncate_snapshot_id` for the next re run.

   It will then find out all the truncate snapshot ID's between the `last_successful_truncate_snapshot_id` and the current truncate snapshot ID and merge their predecessor snapshots into the COW table.

   In the present scenario it will check that `last_successful_truncate_snapshot_id`  is `trunc1` and the current truncate snapshot ID is `trunc2`. Hence, it will only merge `eq7` into the COW table.

</details>

## Running the MOR to COW Write Script

The MOR to COW write script is designed to run periodically, automatically keeping your COW table up-to-date with the latest changes from your MOR table. You can schedule this script as a cron job or through workflow orchestration tools, ensuring that your Databricks queries always reflect the most recent data according to your requirements.

### Execution Platforms

The script can be run on any Spark cluster that has access to your Iceberg catalog and object storage (S3, Azure Blob Storage, GCS, etc.). Common execution platforms include:

- **AWS EMR**: Run the script as a Spark job on EMR clusters
- **Databricks**: Execute as a scheduled job in your Databricks workspace
- **Local Spark**: For testing or small-scale deployments

Simply submit the script using `spark-submit` with the appropriate Iceberg catalog configuration for your environment.

### Scheduling the MOR to COW Write Job

The job execution frequency can be set based on your data freshness requirements and business needs. The script is idempotent, so you can run it as frequently as needed without worrying about duplicate processing. Here are some common scheduling patterns:

- **Hourly**: For real-time dashboards and analytics that require near-live data
- **Every 6 hours**: A balanced approach for most use cases, providing good data freshness without excessive compute costs
- **Daily**: Perfect for overnight batch reporting and scenarios where daily updates are sufficient
- **On-demand**: For low-volume tables or manual refresh workflows where you trigger the write job only when needed

You can configure the schedule using cron syntax, Airflow DAG schedules, or your preferred orchestration tool. Each run will process any new changes since the last write, keeping your COW table synchronized with your MOR table.

For Databricks users, once the COW table is created and being updated periodically, you simply create an external Iceberg table pointing to your COW table location, and you're ready to query with correct results—all deletes and updates properly applied.

## Testing the MOR to COW Write Script Locally

<details>
<summary>View local testing steps</summary>

To understand how the MOR to COW write script works and see it in action, you can test it locally on your system before running it on production data. Follow these steps to run the script locally:

1. Use the following command to quickly spin up the source Postgres and destination (Iceberg/Parquet Writer) services using Docker Compose. This will download the required docker-compose files and start the containers in the background.
   ```bash
   sh -c 'curl -fsSL https://raw.githubusercontent.com/datazip-inc/olake-docs/master/docs/community/docker-compose.yml -o docker-compose.source.yml && \
   curl -fsSL https://raw.githubusercontent.com/datazip-inc/olake/master/destination/iceberg/local-test/docker-compose.yml -o docker-compose.destination.yml && \
   docker compose -f docker-compose.source.yml --profile postgres -f docker-compose.destination.yml up -d'
   ```
   Once the containers are up and running, you can run the the below command to spin up the OLake UI:
   ```bash
   curl -sSL https://raw.githubusercontent.com/datazip-inc/olake-ui/master/docker-compose.yml | docker compose -f - up -d
   ```

   Nowt he OLake UI can be accessed at http://localhost:8000.

2. Set up the configuration:

    <Tabs>
    <TabItem value="source" label="Source Configuration">

    ![source configuration](/img/blog/2025/12/source_config_cow.webp)

    </TabItem>
    <TabItem value="destination" label="Destination Configuraiton">

    ![destination configuration](/img/blog/2025/12/dest_config_cow.webp)

    </TabItem>
    </Tabs>

3. Select the streams and sync the data to Iceberg:

    Since this is a local demo, we will sync the sample table `sample_data` from the source database.

    ![streams configuration](/img/blog/2025/12/streams_cow.webp)

    You can refer to the [Streams Configuration](https://olake.io/docs/getting-started/creating-first-pipeline/#5-configure-streams) for more details about the streams configuration and how to start the sync.

4. The data can be queried from Iceberg using the Spark Iceberg service available at [`localhost:8888`](http://localhost:8888).

   To view the table run the following SQL command:
   ```sql
   %%sql
   SELECT * FROM olake_iceberg.postgres_main_public.sample_data;
   ```

   We can modify the source database by adding and modifying few records and then running the sync again with state enabled to see the changes in the Iceberg table.

   Below command inserts two records into the source database:

   ```bash
   docker exec -it primary_postgres psql -U main -d main -c "INSERT INTO public.sample_data (id, num_col, str_col) VALUES (10, 100, 'First record'), (20, 200, 'Second record');"
   ```

   Let us also update a record in the source database:

   ```bash
   docker exec -it primary_postgres psql -U main -d main -c "UPDATE public.sample_data SET num_col = 150, str_col = 'First record updated' WHERE id = 1;"
   ```

   Now run the sync again. This can be done by simply clicking on the "Sync Now" button in the OLake UI.

   To view the updated table run the following SQL command:
   
   ```sql
   %%sql
   SELECT * FROM olake_iceberg.postgres_main_public.sample_data;
   ```

5. Run the MOR to COW write script to write COW tables:

   After completing the historical load and CDC sync, your Iceberg table now contains both data files and equality delete files in object storage, representing a Merge-on-Read (MOR) table. To write this data as a Copy-on-Write (COW) table, run the MOR to COW write script with the following configuration:

   Update the variables in the [MOR to COW write script](#mor-to-cow-write-script):

   ```python
   COW_DB = "postgres_main_public_cow"
   COW_BASE_LOCATION = "s3a://warehouse/postgres_main_public_cow"
   ```

   Since we're running the script in the Spark Docker container, copy the required files to the container:

   ```bash
   docker cp <PATH_TO_YOUR_WRITE_SCRIPT>/compaction_script.py spark-iceberg:/home/iceberg/compaction_script.py
   docker cp <PATH_TO_YOUR_DESTINATION_DETAILS>/destination.json spark-iceberg:/home/iceberg/destination.json
   ```

   Replace `<PATH_TO_YOUR_WRITE_SCRIPT>` and `<PATH_TO_YOUR_DESTINATION_DETAILS>` with the actual paths to your files on your local machine.

   Enter the Spark container:

   ```bash
   docker exec -it spark-iceberg bash
   ```

   Once inside the container, run the MOR to COW write script using spark-submit:

   ```bash
   spark-submit \
     --master 'local[*]' \
     /home/iceberg/compaction_script.py \
     --destination-details /home/iceberg/destination.json
   ```

   

6. Verify the COW table creation:

   Once the MOR to COW write script runs successfully, we can verify the results in MinIO (the local object storage used in this demo). It can be noticed that:

   - The original MOR table with data files and equality delete files remains in `warehouse/postgres_main_public/sample_data`
   - A new COW table has been created in `warehouse/postgres_main_public_cow/sample_data_cow`, containing the resolved data with all equality deletes applied

   You can verify the COW table by querying it in the Jupyter notebook available at [`localhost:8888`](http://localhost:8888):

   ```sql
   %%sql
   SELECT * FROM olake_iceberg.postgres_main_public_cow.sample_data_cow;
   ```

   This will display the resolved data from your new COW table with all equality deletes applied.
   
   The COW table is now ready to be queried by Databricks as an external Iceberg table, with all updates and deletes properly reflected in the data files.

</details>


## Conclusion

By implementing this automated MOR to COW write solution, you can now enjoy the best of both worlds: OLake's high-performance Merge-on-Read (MOR) writes for efficient CDC ingestion, combined with Databricks-compatible Copy-on-Write (COW) tables for accurate analytics queries. 

